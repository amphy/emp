# EMP 03-12-20 Notes/Worksheet

Hi! Since we will not be able to meet in person this week, I've put together a notes/worksheet that you can work through on your own to get some of the material we would have reviewed during the EMP session. This will be very similar to our regular notes, but with some of the verbal questions added as questions to think about in each section. Please leave feedback on the forum for things you want to see or improvements because I'm not sure how long we will have to be in an online format for.

## Polymorphism and References (review)

#### What is the  **root** object?

<details>
	<summary>Answer:</summary>
	<p>

**Object**
</p></details>

#### What **three methods** do all Java objects inherit from the root object?

<details>
	<summary>Answer:</summary>
	<p>

		
`String toString()`, `boolean equals(Object other)`, and `int hashCode()`
</p></details>

We have talked for the previous two weeks about how to override methods. If I wanted to override the `toString()` method in a class called `Pet`, how would I do that?

<details>
    <summary>Answer:</summary>

```java
public class Pet {
    @Override // Do we need this tag to override?
    public String toString() {
		return "This is a pet"; // can return anything that is a STRING here
	}
}
```
</details>

We've also talked about hierarchy with Java objects. We know when `Dog extends Pet` that `Dog` is the child class and `Pet` is the parent class. When we create a `Dog` object and call the method `speak()` on this object, where do we start to look for or resolve this method?

<details>
	<summary>Answer:</summary>

**The `Dog` Class**
</details>

#### If the method is not there, where do we go next to look for this method?

<details>
	<summary>Answer:</summary>

**The parent class/the next ancestor**
</details>


#### How long do we continue this search for?

<details>
	<summary>Answer:</summary>

**Until the name is found or the search fails**
</details>

Two weeks ago, we talked about **subtype polymorphism**. Let's pretend we have the following code:

```java
public class Pet {
	public void speak() {
		System.out.println("I am a pet");
	}
}

public class Dog extends Pet {
	public void speak() {
		woof();
	}

	public void woof() {
		System.out.println("Woof");
	}
}

```

#### In Java, *every* object can be referred to as at least 2 types. For example, a `Pet` can also be referred to as ________.

<details>
	<summary>Answer:</summary>

**an `Object`**
</details>

#### What are the possible other types for an object of type `Dog`?

<details>
	<summary>Answer:</summary>

**an `Object` or a `Pet`**
</details>

In Java, we upcast automatically. However, instances still **return their types**. What does this mean? Let's take the following example that builds off the `Pet` and `Dog` classes we made earlier.

```java
Dog d = new Dog();
Pet p = (Pet) d; // is it necessary to cast here?
p.speak();
```

#### In the above example, what does the last line print?

<details>
	<summary>Answer:</summary>

**Woof**

Why is this the case? `p` is referencing a `Dog` object even though the reference type is a `Pet`. Since our object is type `Dog`, where do we start looking for the `speak()` method?
</details>